Spring Boot
--------------
Spring security
-------------------
What do you know about spring security?
	authentication
	authorization
	impersonation

authentication
	is a process of validating the identity of the user
authorization
	is a process of checking if the current user is allowed or not
impersonation
	is acting on behalf of other


Authentication
	is done usually using 
		username
		password

	emailAddress & password

	atmNo 	& 	pinNo

	mobileNo	&	otp

	
In modern applications,	
	people are able to login using
		gmail a/c
		facebook a/c

using my gmail or facebook account, i can login to 
	udemy.com
	localhost:8080


we can allow users to login to our web application
	using their gmail / facebook account


Do you remember, 
	we were able to login to 
		GitLab using our github account



This is called OAuth2

Remind me on OAuth2, once we have completed, basic spring security

What is Spring security?
	spring framework provides support for security.
		security starter dependency
		security auto configuration	and also configurer interface and adapter
		User
		UserDetails
		UserDetailsService

1) Basic spring security demo

Demo:
1) File -> New -> Spring starter project
	jun14-security-basic-1
2) dependencies
	spring web
	spring security
3) open the Application class
	Jun14SecurityBasic1Application.java

4) Run this class	Ctrl+F11
	run as spring boot app


port 8080 is already in use
	how to find the process id of the process which runs in 8080

to cmd
	netstat -aon

find the PID of the process that runs in 8080
open task manager
"End Task" that process

Now, run the program

	Using generated security password: 6cb4674a-be95-4d54-8165-e7a4238d617c


Now, this project do not have any controller,
	so lets create

In mvc project
	in pom.xml	
		add the apache tomcat
	prefix
	suffix
	create the WEB-INF/views folder
	create the jsp files there
	create the request mappings



Task:
1) create a spring boot application
2) dependencies
	spring web
	spring security
	apache tomcat
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
3) in application.properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

	prefix
	suffix
	server.port
4) create the folders and create jsp files there
5) create a controller and create get mappings for the jsp
6) Run the application
7) go to browser and check the get mappings 
8) username:	user
    password:	take it from the console

Observation:
	every time, we restart the application,
		we get a new password being generated

	There is a SecurityAutoConfiguration
		(we excluded and did one observation)
	if we have not configured the security, it is automatically configured
		spring.security.user.name=user
		spring.security.user.password (is random)


Task:
we are going to fix our own username and password
	in application.properties
		spring.security.user.name=<<username>>
		spring.security.user.password=<<password>>



So, we are able to choose our own username and password.
But keeping the username and password in "application.properties" is not a good idea.

Yesterday, we created signup and login pages in MVC project.
we were able to signup and able to login based on the username and password from the database

What is the difference, when we use spring security?????
	The biggest difference is,
		in spring security, we do not write the code for authentication in our controller.

we will focus on the core business area. The security part is taken care by another team.

---------------------------------
Now, that we are able to choose our username and password,
but we dont' want to mention the credentials in application.properties
Rather, we will provide it in java code.

Demo:
	create our own configuration class		
1) right click the base package and create a new class
	com.wirpo.hrms.config
		MyConfiguration

	@Configuration
	public class MyConfiguration 
		can implement WebSecurityConfigurer
		or
		can extend WebSecurityConfigurerAdapter

2) we extend WebSecurityConfigurerAdapter
and
3) override the
	configure method. There are 3 overloaded versions of this method, take the following version:

	@Autowired
	private MyUserDetailsService userDetailsService;

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(userDetailsService);
	}
	@Bean
	public PasswordEncoder passwordEncoder()
	{
		return NoOpPasswordEncoder.getInstance();
	}

@Service
public class MyUserDetailsService implements UserDetailsService
{
	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		return new User("ravi", "ravi@123", new ArrayList<>());
	}
}
-----------------------------------
Upto this,
we have created a spring boot mvc project
with spring security

configuration
	override the configure method
	passwordEncoder bean

user details service
	@Service
		and we have overridden loadUserByUserName
			here, we gave dummy username and password

Now, we are going to use JpaRepository
so that we will allow users to login using 
	any of the user records found in the database

Demo:
1) create a spring boot application
	spring web
	spring security
	spring data jpa
	mysql driver


2) whenever we have spring data jpa,
	we should configure the datasource in 

3) application.properties
	spring.datasource.url=jdbc:mysql://localhost:3306/wipro3
spring.datasource.username=root
spring.datasource.password=

spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=12
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000

spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect
spring.jpa.properties.hibernate.id.new_generator_mappings = false
spring.jpa.properties.hibernate.format_sql = false
spring.jpa.hibernate.ddl-auto=update
# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

spring.jpa.properties.hibernate.show_sql=true


4) we have created 
	entity	(Customer)
	repository	(CustomerRepository)

what about service?
	remember the MyUserDetailsService???????
	we can relate it to  the entity->repository->service
	CustomerService
		implements UserDetailsService
		override loadUserByUsername method
			instead of returning a dummy object,
			use repository to findById

5) create the configuration as similar to previous project
	but autowire the CustomerService

Task:
	Use our own
		entity
		repository
		service		that implements UserDetailsService
		configuration
	and run the project

	this time, we should be able to login using any credentials taken from mysql database.











